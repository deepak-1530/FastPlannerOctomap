                                                                                /** 
                                                                                 * Fast Planner with Octomap and EDT3D library 
                                                                                **/
/**
 * Octomap generation using point cloud from depth camera and pose from PX4-EKF
 * Fixed Window (8,8,8) EDT calculation using EDT3D library
 * Planning in the window using kino-dynamic A* algorithm
 * Horizon limitation due to limitation of range sensor
 * Drone controlled using PX4-Offboard position control
**/

#include"FastPlannerOctomap/utils.h"

/** Planning and mapping headers **/
#include"FastPlannerOctomap/kinodynamic_astar.h"

#include"FastPlannerOctomap/Map.h"

#include"FastPlannerOctomap/edtDistribution.h"

#include"std_msgs/Float64.h"

#include <math.h>

/** Drone states for planner **/
Eigen::Vector3d goalPose, currPose, startPose, startVel, startAcc, goalVel;

/** Overall trajectory **/
std::vector<Eigen::Vector3d> trajectory;
nav_msgs::Path generatedPath;

/** EDT distance for each waypoint in the path generated by fast planner **/
nav_msgs::Path generatedPathEDT;

/** time step to generate the trajectory **/
float deltaT = 0.5;

/** Initialize the planner and mapping objects **/
fast_planner::KinodynamicAstar kAstar;
Map3D::OctoMapEDT costMap3D;

/** decision variables **/
bool goalReceived = false;
bool DESTINATION_REACHED = false;
bool PLAN = false;
int startOver = 0;

int count;     // count for planning iteration

#define INF 1000 // inifinity

// trajectory regeneration
std::vector<Eigen::Vector3d> prevTraj;


/** Cost Map visualization **/
visualization_msgs::MarkerArray costMap_vis;

ros::Publisher queryPointEdt;
octomap::point3d qPt;
bool queryPtUpdated = false;

/**********************************************************************************************************************************************************
 * -------------------------------------------------------------------Callbacks---------------------------------------------------------------------------*
***********************************************************************************************************************************************************/

/** octomap callback **/
void octomap_cb(const octomap_msgs::Octomap octo)
{
    costMap3D.new_tree = octomap_msgs::binaryMsgToMap(octo);  // this is the abstract tree for an octomap
    costMap3D.tree = dynamic_cast<octomap::OcTree*>(costMap3D.new_tree);

    //std::cout<<"final tree has "<<costMap3D.tree->getNumLeafNodes()<<" leaves"<<std::endl;

    // get the min and max of the map
    costMap3D.setMinMax();
    costMap3D.isOctomapUpdated = true;
}

/** current drone position callback **/
void local_pose_cb(const geometry_msgs::PoseStamped pose)
{
    currPose(0) = pose.pose.position.x;
    currPose(1) = pose.pose.position.y;
    currPose(2) = pose.pose.position.z;
}

/** get goal location **/
void goal_pose_cb(const geometry_msgs::PoseStamped pose)
{
    goalReceived = true;

    goalPose(0) = pose.pose.position.x;
    goalPose(1) = pose.pose.position.y;
    
    std::cout<<"Enter the height at the goal point ";
    std::cin>>goalPose(2);

    std::cout<<"Goal Pose is ... "<<goalPose.transpose()<<std::endl;
    std::cout<<"\n";
}

/** query edt for any published point **/
void edt_cb(const geometry_msgs::PoseStamped msg)
{
    octomap::point3d queryPt(msg.pose.position.x, msg.pose.position.y, msg.pose.position.z);

    std::cout<<"Here "<<std::endl;
    qPt = queryPt;
    queryPtUpdated = true;
    DynamicEDTOctomap costMap(5.0, costMap3D.tree, costMap3D.start, costMap3D.end, false);
    
    // check if the point is in the map
    std_msgs::Float64 edt;
    if(costMap3D.isInMap(queryPt))
    {
        std::cout<<costMap3D.start<<"  "<<costMap3D.end<<std::endl;
        std::cout<<"Inside Map"<<std::endl;
        std::cout<<queryPt<<std::endl;
        float dist = costMap.getDistance(queryPt);
        std::cout<<"Distance of queried point "<<queryPt<<" is :-> "<<dist<<std::endl;

        edt.data = dist;
    }
    
    else
    {
        edt.data = 1000;
    }
    queryPointEdt.publish(edt);
    
}

///////////////////////////////////////////////////////////////////
/**  Plan the path until goal is reached **/
void plan(ros::Publisher path,  ros::Publisher map, ros::Publisher pathEDT)
{
    while(!DESTINATION_REACHED || ros::ok()) /** until the goal is reached or the node is killed, keep running the process **/
    {
        if(!ros::ok())
        {
            break;
        }
        if(count == 0) // 1st iteration
        {   
            std::cout<<"Starting pose is "<<currPose<<std::endl;
            costMap3D.setStartPosition(currPose); // set this point as the point where map was initialized
            startPose = currPose;
            startPose(0) += 0.5;  // start planning from a small distance away from the starting location  
            PLAN = true;
            //count++;
        }
        else
        {
            if(costMap3D.ifUpdateMap(currPose))
            {
                costMap3D.setStartPosition(currPose);
                PLAN = true;
                //count++;
            }
            else
            {
                if(!ros::ok)
                {
                    break;
                }
                PLAN = false;
                ros::spinOnce();
                continue;
            }
        }


        if(PLAN)
        {    
            PLAN = false;

            // set the map range with respect to the current point
            costMap3D.setMapRange(currPose);

            std::cout<<"Updating the map from ... "<<costMap3D.start<<" to"<<costMap3D.end<<std::endl;

            // calculate EDT now
            DynamicEDTOctomap DistMap(5.0, costMap3D.tree, costMap3D.start, costMap3D.end, false); // take unknwon region as unoccupied
            DistMap.update();

            octomap::point3d qp(24.23, 0.0 ,1.25);


            // set this as the costMap in the costMap3D object
            costMap3D.costMap = &DistMap;

            if(queryPtUpdated)
            {std::cout<<"--------------------------------------------------------------- Distance is "<<costMap3D.costMap->getDistance(qp)<<std::endl;
                std_msgs::Float64 edt;
                edt.data = costMap3D.costMap->getDistance(qPt);
                queryPointEdt.publish(edt);
                queryPtUpdated = false;

            }



            // set planning range and pass cost map to planner
            kAstar.init(costMap3D.start, costMap3D.end, currPose);
            kAstar.setEnvironment(&DistMap);

            // visualize the EDT Map
            costMap3D.getCostMapMarker(costMap_vis, &DistMap, map);

            // run the planner now
            int status;
            
            if(count == 0 || startOver == 1)
                {
                    status = kAstar.search(startPose, startVel, startAcc, goalPose, goalVel, true, false, 0.0);
                    startOver = 0;
                    ros::spinOnce();
                }                
            else
                {
                    status = kAstar.search(startPose, startVel, startAcc, goalPose, goalVel, false, false, 0.0);
                    ros::spinOnce();
                }
                        
            std::cout<<"Planner output status is >>>>> "<<status<<std::endl;
            std::cout<<"\n";

            if(status==3)
                {
                    std::cout<<"No trajectory found ..."<<std::endl;
                    std::cout<<"Trying again ..."<<std::endl;
                    std::cout<<"\n";
                    ros::spinOnce();
                    return;
                }

            if(status==2)
                {
                    std::cout<<"+++++++++++__________________Goal reached__________________++++++++++++ ...."<<std::endl;
                    DESTINATION_REACHED = true;
                    //break;
                }
            
            /** get the planned path **/
            std::vector<Eigen::Vector3d> currTraj = kAstar.getKinoTraj(deltaT);
            prevTraj = currTraj;

            count++;

            for(auto i = currTraj.begin(); i != currTraj.end(); i++)
            {
                geometry_msgs::PoseStamped p;
                
                geometry_msgs::PoseStamped pEdt;

                Eigen::Vector3d pos = *i;
                Eigen::Vector3d pos_next;

                // store the distance to nearest obstacle for each wayoint
                octomap::point3d pt_(pos(0), pos(1), pos(2));
                octomap::point3d ptObs;

                float dist;
                DistMap.getDistanceAndClosestObstacle(pt_, dist, ptObs);
                pEdt.pose.position.x = ptObs.x();
                pEdt.pose.position.y = ptObs.y();
                pEdt.pose.position.z = ptObs.z();
                
                generatedPathEDT.header.stamp = ros::Time::now();
                generatedPathEDT.header.frame_id = "map";
                generatedPathEDT.poses.push_back(pEdt);

              //  std::cout<<"Waypoint in current trajectory ..."<<pos<<std::endl;

                if(-INF<pos(0)<INF && -INF<pos(1)<INF && -INF<pos(2)<INF)
                { 
                    p.pose.position.x = pos(0);
                    p.pose.position.y = pos(1);
                    p.pose.position.z = pos(2);

                if(i!=currTraj.end()-1)
                    {
                        pos_next = *(i+1);

                        float currYaw = atan2((pos_next(1) - pos(1)),(pos_next(0) - pos(0)));
                        float qz = sin(currYaw/2.0);
                        float qw = cos(currYaw/2.0);

                        p.pose.orientation.x = 0.0;
                        p.pose.orientation.y = 0.0;
                        p.pose.orientation.z = qz;
                        p.pose.orientation.w = qw;

                        generatedPath.header.stamp = ros::Time::now();
                        generatedPath.header.frame_id = "map";
                        generatedPath.poses.push_back(p); 
                    }
                }
                    ros::spinOnce();
            }

            // publish the path
            path.publish(generatedPath);

            // publish the EDT data for the path
            pathEDT.publish(generatedPathEDT);

            // insert this in the global trajectory
            trajectory.insert(trajectory.end(), currTraj.begin(), currTraj.end());
            std::cout<<"Global trajectory size ... "<<trajectory.size()<<std::endl;
            std::cout<<"\n";

            kAstar.reset();
            ros::spinOnce();

            if(!ros::ok() || status==2)
            {
                if(status==2)
                {
                    std::cout<<"***************** Reached goal ********************"<<std::endl;
                    return;
                }
                break;
            }

            // set the starting point for the next planning iteration
            auto it = trajectory.end() - 1;
            startPose = *it;
            std::cout<<">>>>>>>>>>>>>>__________Next starting point for the planner is "<<startPose.transpose()<<std::endl;
            std::cout<<"\n";

        }        
            ros::spinOnce();

            if(!ros::ok())
            {
                break;
            }
    }
}

int main(int argc, char **argv)
{
    /** set all the subscribers and publishers **/
    ros::init(argc, argv, "fast_planner_octomap");
    ros::NodeHandle n;

    /** Subscribers **/
    ros::Subscriber oct          = n.subscribe<octomap_msgs::Octomap>("/octomap_binary",1,octomap_cb);
    ros::Subscriber pos          = n.subscribe<geometry_msgs::PoseStamped>("/mavros/local_position/pose",10,local_pose_cb);
    ros::Subscriber goal         = n.subscribe<geometry_msgs::PoseStamped>("/move_base_simple/goal",1,goal_pose_cb);
 
    /** Publishers **/
    ros::Publisher path          = n.advertise<nav_msgs::Path>("/fastPlanner_path",1); 
    ros::Publisher map           = n.advertise<visualization_msgs::MarkerArray>("/costMap_marker_array",1); // one at a time
    ros::Publisher pathEDT       = n.advertise<nav_msgs::Path>("/fastPlanner_path_EDT",1);

    /** EDT Subscriber and distance publisher **/
    ros::Subscriber queryPoint   = n.subscribe<geometry_msgs::PoseStamped>("/query_point_topic", 1, edt_cb);
    queryPointEdt                = n.advertise<std_msgs::Float64>("/query_point_distance", 1);

    ros::Rate rate(20);

    std::cout<<"Start over ...? ";
    std::cin>>startOver;

    while(!goalReceived)
    {
        //std::cout<<"Waiting for goal ..."<<std::endl;
        ros::spinOnce();
        rate.sleep();

        if(!ros::ok())
        {
            break;
        }
    }

    if(goalReceived)
    {
        std::cout<<"Goal received "<<goalPose.transpose()<<std::endl;
        std::cout<<"\n";
        std::cout<<"Setting initial velocity and acceleration .."<<std::endl;

        goalVel  = Eigen::Vector3d::Zero();  // velocity at goal location set to 0
        startVel = Eigen::Vector3d::Zero(); // starting with 0 initial velocity i.e. static 
        startAcc = Eigen::Vector3d::Ones();  // set the starting acceleration as (1,1,1)
        
        std::cout<<"Starting planning now ..."<<std::endl;

        kAstar.setParam(n); // set the fast planner parameters

        plan(path, map, pathEDT);
    }

    return 0;
}