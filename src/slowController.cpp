// OFFBOARD POSITION CONTROL TO MANEUVER THE DRONE 
// OVER THE TRAJECTORY GENERATED BY FAST PLANNER

#include"FastPlanner_Octomap/utils.h"
#include<mavros_msgs/PositionTarget.h>
#include<mavros_msgs/State.h>
#include<math.h>


                                        /** Subscribe to the nav_msgs/Path topic
                                         *  if path available -> call controller function
                                         * Traverse over the path and publish the waypoints
                                        **/

bool trajectoryUpdated = false;

nav_msgs::Path trajectory; // this receives the trajectory every time subscriber is called

int i = 0; // index in the trajectory

int count = 0; // count to see if the controller starts just now or not.

int posMsg = 0;

Eigen::Vector3d goal, currPose;

mavros_msgs::State current_state;


void path_cb(nav_msgs::Path traj)
{
    trajectory = traj;
    trajectoryUpdated = true;
}


void goal_pose_cb(geometry_msgs::PoseStamped pose)
{
    goal(0) = pose.pose.position.x;
    goal(1) = pose.pose.position.y;
    goal(2) = 1.2;
}

void local_pose_cb(const geometry_msgs::PoseStamped pose)
{
    currPose(0) = pose.pose.position.x;
    currPose(1) = pose.pose.position.y;
    currPose(2) = pose.pose.position.z;
}


void state_cb(const mavros_msgs::State::ConstPtr& msg){
    current_state = *msg;
}


void control(ros::Publisher pub, ros::Rate rate, ros::Publisher pub_2)
{
    
    if(trajectoryUpdated)
    {
        trajectoryUpdated = false; 
        std::cout<<"Size of trajectory is: "<<trajectory.poses.size()<<std::endl;
        nav_msgs::Path traj_local = trajectory;

        mavros_msgs::PositionTarget waypt;

        waypt.coordinate_frame = mavros_msgs::PositionTarget::FRAME_LOCAL_NED;
        waypt.type_mask =mavros_msgs::PositionTarget::IGNORE_AFX | 
                         mavros_msgs::PositionTarget::IGNORE_AFY | 
                         mavros_msgs::PositionTarget::IGNORE_AFZ |
                         mavros_msgs::PositionTarget::IGNORE_VX  | 
                         mavros_msgs::PositionTarget::IGNORE_VY  | 
                         mavros_msgs::PositionTarget::IGNORE_VZ;
                   

        while(i<traj_local.poses.size())
        {
            if(!ros::ok())
            {
                break;
            }
            
            // if posMsg is 1 -> use the message mavros_msgs::
            
            if(posMsg == 1)
            {
                waypt.header.stamp = ros::Time::now();
                waypt.position.x   = traj_local.poses.at(i).pose.position.x;
                waypt.position.y   = traj_local.poses.at(i).pose.position.y;
                waypt.position.z   = traj_local.poses.at(i).pose.position.z;
                
                float qx = traj_local.poses.at(i).pose.orientation.x;
                float qy = traj_local.poses.at(i).pose.orientation.y;
                float qz = traj_local.poses.at(i).pose.orientation.z;
                float qw = traj_local.poses.at(i).pose.orientation.w;

                waypt.yaw = atan2(2.0*(qy*qz + qw*qx), qw*qw - qx*qx - qy*qy + qz*qz)*57.3;
                std::cout<<waypt.yaw<<std::endl;
                waypt.yaw_rate     = 0.5;
            }

            Eigen::Vector3d wp_eigen;
            wp_eigen(0) = traj_local.poses.at(i).pose.position.x;
            wp_eigen(1) = traj_local.poses.at(i).pose.position.y;
            wp_eigen(2) = traj_local.poses.at(i).pose.position.z;


            Eigen::Vector3d diff = wp_eigen - currPose;

            pub_2.publish(waypt);
            ros::Duration(0.4).sleep();
            i++;
            
            /*
            while(diff.norm()>0.0) // distance between current location and the next waypoint
            {
                // keep publishing the same point
                //std::cout<<"Published point is "<<i<<std::endl;

                if(posMsg==1)
                {
                    pub_2.publish(waypt);
                }
                if(posMsg==0)
                {
                pub.publish(traj_local.poses.at(i));
                }
                diff = wp_eigen - currPose;
                ros::spinOnce();

                if(diff.norm()<0.2 || !ros::ok())
                {
                    i++;
                    break;
                }
                
            }
            */

        }
        }
    
    else
    {
        std::cout<<"No trajectory available"<<std::endl;
    }
}



int main(int argc, char** argv)
{
    std::cout<<"Enter the controller mode ... (0 for default and 1 for modified) ";
    std::cin>>posMsg;
    std::cout<<"\n";
    /*
    if(posMsg != 0  posMsg != 1)
    {
        std::cout<<"Enter either 0  or 1 only ... ";
        std::cin>>posMsg;
        std::cout<<"\n";
    }
    */
    std::cout<<"Mode is "<<posMsg<<std::endl;

    ros::init(argc, argv, "drone_control");
    ros::NodeHandle n;

    ros::Subscriber path = n.subscribe<nav_msgs::Path>("/fastPlanner_path",1, path_cb);
    ros::Subscriber goal = n.subscribe<geometry_msgs::PoseStamped>("/move_base_simple/goal",1,goal_pose_cb); 
    ros::Subscriber loc = n.subscribe<geometry_msgs::PoseStamped>("/mavros/local_position/pose",10,local_pose_cb);
    ros::Subscriber state_sub = n.subscribe<mavros_msgs::State>("mavros/state", 10, state_cb);

    ros::Publisher wp_pub = n.advertise<geometry_msgs::PoseStamped>("/mavros/setpoint_position/local",10);
    ros::Publisher wp_pub_2 = n.advertise<mavros_msgs::PositionTarget>("/mavros/setpoint_raw/local",10);

    /* Services */
    ros::ServiceClient  arming_client = n.serviceClient<mavros_msgs::CommandBool>("mavros/cmd/arming");
    ros::ServiceClient  landing_client = n.serviceClient<mavros_msgs::CommandTOL>("mavros/cmd/landing");
    ros::ServiceClient  set_mode_client = n.serviceClient<mavros_msgs::SetMode>("mavros/set_mode");

    ros::Rate rate(20);

    while(!trajectoryUpdated || !ros::ok())
    {
        std::cout<<"Waiting for trajectory"<<std::endl;
        ros::spinOnce();
        rate.sleep();

        if(!ros::ok())
            {
                break;
            }
    }

    if(trajectoryUpdated)
    {
        geometry_msgs::PoseStamped initPose;


        if(current_state.mode != "OFFBOARD")
        {
            std::cout<<"Controller started ... "<<std::endl;

            initPose.pose.position.x = currPose(0);
            initPose.pose.position.y = currPose(1);
            initPose.pose.position.z = currPose(2);

            for(int i = 0; i<100 and ros::ok(); i++)
            {
                wp_pub.publish(initPose);
                ros::spinOnce();
                rate.sleep();
            }

            mavros_msgs::SetMode offb_set_mode;
            offb_set_mode.request.custom_mode = "OFFBOARD";

            mavros_msgs::CommandBool arm_cmd;
            arm_cmd.request.value = true;

        /** set mode to offboard **/
            if(set_mode_client.call(offb_set_mode) &&
                    offb_set_mode.response.mode_sent)
                {
                        ROS_INFO("Offboard enabled");
                }

        }

        count++;

        while(ros::ok())
        {
            control(wp_pub, rate, wp_pub_2);

            rate.sleep();      
            ros::spinOnce();

            if(!ros::ok())
            break;

        }

    count++;
    }

    ros::spinOnce();
    return 0;
}